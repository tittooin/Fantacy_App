import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:go_router/go_router.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:uuid/uuid.dart';
import 'package:axevora11/features/cricket_api/domain/cricket_match_model.dart';
import 'package:axevora11/features/cricket_api/domain/contest_model.dart';

class ContestCreatorScreen extends ConsumerStatefulWidget {
  final CricketMatchModel match;

  const ContestCreatorScreen({super.key, required this.match});

  @override
  ConsumerState<ContestCreatorScreen> createState() => _ContestCreatorScreenState();
}

class _ContestCreatorScreenState extends ConsumerState<ContestCreatorScreen> {
  final _formKey = GlobalKey<FormState>();
  
  // Controllers
  final _entryFeeController = TextEditingController(text: '49');
  final _spotsController = TextEditingController(text: '100');
  final _prizePoolController = TextEditingController();
  final _commissionController = TextEditingController(text: '20'); // %

  String _category = 'Mega Contest';
  bool _isAutoCalculating = true;
  bool _imageLoading = false;
  
  // Advanced Options
  bool _isGuaranteed = false;
  bool _isFlexible = false;

  // Metrics
  double _totalCollection = 0;
  double _projectedProfit = 0;
  
  // Payout Builder State
  List<Map<String, dynamic>> _payoutTiers = [];

  // Helper for Chips
  Widget _buildPresetChip(String label, double fee, int spots, String cat, bool guaranteed, bool flexible) {
    return ActionChip(
      label: Text(label),
      backgroundColor: _category == cat && double.tryParse(_entryFeeController.text) == fee 
          ? Colors.indigo.shade100 
          : Colors.grey.shade200,
      onPressed: () {
        setState(() {
          _entryFeeController.text = fee.toString();
          _spotsController.text = spots.toString();
          _category = cat;
          _isGuaranteed = guaranteed;
          _isFlexible = flexible;
          _isAutoCalculating = true; // Reset auto-calc
        });
        _calculateMetrics(); // Force recalc
      },
    );
  }

  InputDecoration _buildInputDecoration(String label, {String? suffixText, String? prefixText}) {
    return InputDecoration(
      labelText: label,
      suffixText: suffixText,
      prefixText: prefixText,
      border: const OutlineInputBorder(),
      filled: true,
      fillColor: Colors.white,
      labelStyle: const TextStyle(color: Colors.black87),
      hintStyle: const TextStyle(color: Colors.black54),
      isDense: true,
    );
  }
  
  void _addPayoutTier() {
    int nextStart = 1;
    if (_payoutTiers.isNotEmpty) {
      nextStart = (_payoutTiers.last['rankEnd'] as int) + 1;
    }
    setState(() {
      _payoutTiers.add({
        'rankStart': nextStart,
        'rankEnd': nextStart,
        'amount': 0,
      });
    });
  }

  void _removePayoutTier(int index) {
    setState(() {
      _payoutTiers.removeAt(index);
    });
  }

  double _calculateTotalPayout() {
    double total = 0;
    for (var tier in _payoutTiers) {
      int count = (tier['rankEnd'] as int) - (tier['rankStart'] as int) + 1;
      total += count * (tier['amount'] as num);
    }
    return total;
  }

  @override
  void initState() {
    super.initState();
    _calculateMetrics();
    _entryFeeController.addListener(_calculateMetrics);
    _spotsController.addListener(_calculateMetrics);
    _commissionController.addListener(_calculateMetrics);
  }

  @override
  void dispose() {
    _entryFeeController.dispose();
    _spotsController.dispose();
    _prizePoolController.dispose();
    _payoutTiers.clear();
    super.dispose();
  }

  void _showAutoGenerateDialog() {
    final TextEditingController percentController = TextEditingController(text: '50');
    
    showDialog(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text("Auto-Generate Payouts"),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Text("Select percentage of users who will win:"),
            const SizedBox(height: 16),
            TextField(
              controller: percentController,
              keyboardType: TextInputType.number,
              decoration: const InputDecoration(
                labelText: "Winning %", 
                suffixText: "%",
                border: OutlineInputBorder(),
              ),
            ),
          ],
        ),
        actions: [
          TextButton(onPressed: () => Navigator.pop(ctx), child: const Text("Cancel")),
          ElevatedButton(
            onPressed: () {
              double p = double.tryParse(percentController.text) ?? 50;
              Navigator.pop(ctx);
              _generatePayoutsAlgorithm(p);
            },
            child: const Text("Generate"),
          )
        ],
      )
    );
  }

  void _generatePayoutsAlgorithm(double winningPercent) {
    if (_spotsController.text.isEmpty || _entryFeeController.text.isEmpty) return;
    
    int totalSpots = int.parse(_spotsController.text);
    double entryFee = double.parse(_entryFeeController.text);
    double targetPool = double.parse(_totalCollection.toString()) * ((100 - double.parse(_commissionController.text))/100); 
    // Or we use the manually entered pool if we want to respect budget. 
    // But Auto-Gen usually assumes "Standard Commission" logic.
    // Let's stick to: Distribute (Collection - Commission).

    int totalWinners = (totalSpots * (winningPercent / 100)).floor();
    if (totalWinners < 1) totalWinners = 1;

    List<Map<String, dynamic>> newTiers = [];
    double remainingAmount = targetPool;
    
    // Strategy:
    // 1. Last Tier (Bottom 50% of winners) gets ~Entry Fee.
    // 2. Top Tier gets ~10-20% of Pool.
    // 3. Middle tiers bridge the gap.

    // Simple Distribution Logic (Mock-up for MVP):
    // Tier 1: Rank 1 -> 20%
    // Tier 2: Rank 2 -> 10%
    // Tier 3: Rank 3 -> 5%
    // Tier 4: Rank 4-10 -> Share 15%
    // Tier 5: Rank 11-Last -> Share Remaining (approx Entry Fee)

    // Better Simple Logic:
    // Last Range (e.g. Rank 11-50): Amount = Entry Fee.
    int lastTierStart = (totalWinners * 0.2).floor() + 1; // Top 20% get premium, rest get base.
    if (lastTierStart <= 3) lastTierStart = 4; // Ensure verified top ranks
    
    int lastTierCount = totalWinners - lastTierStart + 1;
    double lastTierPayout = entryFee; // Money back
    double payoutForLastTier = lastTierCount * lastTierPayout;
    
    if (payoutForLastTier > remainingAmount) {
      // Budget too tight, everyone gets proportional share
      // Fallback to "Winner Takes All" if too small
      newTiers = [{'rankStart': 1, 'rankEnd': totalWinners, 'amount': (remainingAmount / totalWinners).floor()}];
    } else {
      remainingAmount -= payoutForLastTier;
      
      // Top Tiers Distribution
      double rank1 = remainingAmount * 0.4; // 40% of surplus
      double rank2 = remainingAmount * 0.2; // 20%
      double rank3 = remainingAmount * 0.1; // 10%
      
      // Tier 4 (Rank 4 to lastTierStart-1)
      double midTierPool = remainingAmount * 0.3; // 30%
      int midStart = 4;
      int midEnd = lastTierStart - 1;
      double midAmount = 0;
      if (midEnd >= midStart) {
         midAmount = midTierPool / (midEnd - midStart + 1);
      } else {
         // If no mid tier, add to rank 1-3
         rank1 += midTierPool * 0.5;
         rank2 += midTierPool * 0.3;
         rank3 += midTierPool * 0.2;
      }

      newTiers.add({'rankStart': 1, 'rankEnd': 1, 'amount': rank1.floor()});
      if (totalWinners >= 2) newTiers.add({'rankStart': 2, 'rankEnd': 2, 'amount': rank2.floor()});
      if (totalWinners >= 3) newTiers.add({'rankStart': 3, 'rankEnd': 3, 'amount': rank3.floor()});
      if (midEnd >= midStart) {
         newTiers.add({'rankStart': midStart, 'rankEnd': midEnd, 'amount': midAmount.floor()});
      }
      if (lastTierCount > 0) {
         newTiers.add({'rankStart': lastTierStart, 'rankEnd': totalWinners, 'amount': lastTierPayout.floor()});
      }
    }

    setState(() {
      _payoutTiers = newTiers;
    });
    // Trigger calc to update UI summary
    Future.delayed(Duration.zero, () => _calculateMetrics());
  }

  void _calculateMetrics() {
    double entry = double.tryParse(_entryFeeController.text) ?? 0;
    int spots = int.tryParse(_spotsController.text) ?? 0;
    double collection = entry * spots;
    
    double totalPayouts = _calculateTotalPayout();

    if (totalPayouts > 0) {
      // Logic: Payouts define the Prize Pool and Profit
      double profit = collection - totalPayouts;
      
      setState(() {
        _totalCollection = collection;
        _projectedProfit = profit;
        _prizePoolController.text = totalPayouts.toStringAsFixed(0);
        
        // Update Commission % for display (avoid looping if possible, or just ignore controller)
        if (collection > 0) {
           // We remove the listener temporarily to avoid loop? 
           // actually setting text triggers listener.
           // Simplified: We won't update the controller text to avoid cursor jumps/loops, 
           // but we can rely on _projectedProfit for the UI.
        }
      });
    } else if (_isAutoCalculating) {
      // Logic: Percentage defines Profit (Default)
      double commPercent = double.tryParse(_commissionController.text) ?? 0;
      double commissionAmount = collection * (commPercent / 100);
      double prizePool = collection - commissionAmount;

      setState(() {
        _totalCollection = collection;
        _projectedProfit = commissionAmount;
        _prizePoolController.text = prizePool.toStringAsFixed(0);
      });
    }
  }

  Future<void> _createContest() async {
    if (!_formKey.currentState!.validate()) return;

    setState(() => _imageLoading = true);

    try {
      final contestId = const Uuid().v4();
      final contest = ContestModel(
        id: contestId,
        matchId: widget.match.id,
        entryFee: double.parse(_entryFeeController.text),
        totalSpots: int.parse(_spotsController.text),
        filledSpots: 0,
        prizePool: double.parse(_prizePoolController.text),
        category: _category,
        isGuaranteed: _isGuaranteed,
        isFlexible: _isFlexible,
        winningBreakdown: _payoutTiers,
        createdAt: DateTime.now(),
      );

      await FirebaseFirestore.instance
          .collection('matches')
          .doc(widget.match.id.toString())
          .collection('contests')
          .doc(contestId)
          .set(contest.toJson());

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('Contest Created Successfully!'), backgroundColor: Colors.green),
        );
        context.pop();
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Error: $e'), backgroundColor: Colors.red),
        );
      }
    } finally {
      if (mounted) setState(() => _imageLoading = false);
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Create Contest')),
      body: SingleChildScrollView(
        padding: const EdgeInsets.all(16.0),
        child: Form(
          key: _formKey,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Match Info Card
              Card(
                color: Colors.indigo.shade50,
                child: ListTile(
                  title: Text("${widget.match.team1ShortName} vs ${widget.match.team2ShortName}"),
                  subtitle: Text(widget.match.seriesName),
                  leading: const Icon(Icons.sports_cricket, color: Colors.indigo),
                ),
              ),
              const SizedBox(height: 20),

              Row(
                children: [
                   Expanded(
                       child: TextFormField(
                       controller: _entryFeeController,
                       style: const TextStyle(color: Colors.black),
                       decoration: _buildInputDecoration('Entry Fee (â‚¹)'),
                       keyboardType: TextInputType.number,
                     ),
                   ),
                   const SizedBox(width: 16),
                   Expanded(
                       child: TextFormField(
                       controller: _spotsController,
                       style: const TextStyle(color: Colors.black),
                       decoration: _buildInputDecoration('Total Spots'),
                       keyboardType: TextInputType.number,
                     ),
                   ),
                ],
              ),
              const SizedBox(height: 16),
              
              DropdownButtonFormField<String>(
                value: _category,
                style: const TextStyle(color: Colors.black),
                dropdownColor: Colors.white,
                decoration: _buildInputDecoration('Contest Category'),
                items: ['Mega Contest', 'Head 2 Head', 'Winner Takes All', 'Practice']
                    .map((e) => DropdownMenuItem(value: e, child: Text(e)))
                    .toList(),
                onChanged: (v) => setState(() => _category = v!),
              ),
              const SizedBox(height: 24),

              // Presets
              const Text("Quick Presets", style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
              const SizedBox(height: 8),
              SingleChildScrollView(
                scrollDirection: Axis.horizontal,
                child: Row(
                  children: [
                    _buildPresetChip("Mega GL", 49, 1000, "Mega Contest", true, false),
                    const SizedBox(width: 8),
                    _buildPresetChip("Head 2 Head", 575, 2, "Head 2 Head", true, false),
                    const SizedBox(width: 8),
                    _buildPresetChip("Winner Takes All", 100, 4, "Winner Takes All", true, false),
                    const SizedBox(width: 8),
                    _buildPresetChip("Practice", 0, 100, "Practice", false, false),
                  ],
                ),
              ),
              const SizedBox(height: 16),

              // Payout Structure Section
              const Divider(),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  const Text("Payout Structure", style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
                  TextButton.icon(
                    onPressed: _addPayoutTier,
                    icon: const Icon(Icons.add),
                    label: const Text("Add Tier"),
                  )
                ],
              ),
              const SizedBox(height: 8),
              Center(
                 child: ElevatedButton.icon(
                  onPressed: _showAutoGenerateDialog, 
                  icon: const Icon(Icons.auto_fix_high), 
                  label: const Text("Auto Generate Payouts ðŸª„"),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.purple.shade50,
                    foregroundColor: Colors.purple,
                  ),
                ),
              ),
              const SizedBox(height: 8),
              
              ..._payoutTiers.asMap().entries.map((entry) {
                int index = entry.key;
                Map<String, dynamic> tier = entry.value;
                return Card(
                  child: Padding(
                    padding: const EdgeInsets.all(8.0),
                    child: Row(
                      children: [
                        Expanded(child: TextFormField(
                          initialValue: tier['rankStart'].toString(),
                          style: const TextStyle(color: Colors.black),
                          decoration: _buildInputDecoration('From Rank'),
                          keyboardType: TextInputType.number,
                          onChanged: (val) {
                             tier['rankStart'] = int.tryParse(val) ?? tier['rankStart'];
                             setState((){});
                          },
                        )),
                        const SizedBox(width: 8),
                         Expanded(child: TextFormField(
                          initialValue: tier['rankEnd'].toString(),
                          style: const TextStyle(color: Colors.black),
                          decoration: _buildInputDecoration('To Rank'),
                          keyboardType: TextInputType.number,
                          onChanged: (val) {
                             tier['rankEnd'] = int.tryParse(val) ?? tier['rankEnd'];
                             setState((){});
                          },
                        )),
                        const SizedBox(width: 8),
                        Expanded(child: TextFormField(
                          initialValue: tier['amount'].toString(),
                          style: const TextStyle(color: Colors.black),
                          decoration: _buildInputDecoration('Amount', prefixText: 'â‚¹'),
                          keyboardType: TextInputType.number,
                           onChanged: (val) {
                             tier['amount'] = int.tryParse(val) ?? tier['amount'];
                             setState((){});
                          },
                        )),
                        IconButton(icon: const Icon(Icons.delete, color: Colors.red), onPressed: () => _removePayoutTier(index))
                      ],
                    ),
                  ),
                );
              }),
              
              const SizedBox(height: 8),
              if (_payoutTiers.isNotEmpty)
                Container(
                  padding: const EdgeInsets.all(8),
                  color: _calculateTotalPayout() > double.parse(_prizePoolController.text) ? Colors.red.shade50 : Colors.green.shade50,
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Text("Total Payout: â‚¹${_calculateTotalPayout().toStringAsFixed(0)}"),
                      Text("Pool: â‚¹${_prizePoolController.text}", style: const TextStyle(fontWeight: FontWeight.bold)),
                    ],
                  ),
                ),

              const SizedBox(height: 24),

              const Divider(),
              
              // Toggles
              SwitchListTile(
                title: const Text("Guaranteed Contest"),
                subtitle: const Text("Prize Pool remains same even if spots are not full"),
                value: _isGuaranteed,
                onChanged: (val) => setState(() => _isGuaranteed = val),
              ),
              SwitchListTile(
                title: const Text("Flexible Contest"),
                subtitle: const Text("Prize Pool reduces if participation is low"),
                value: _isFlexible,
                onChanged: (val) => setState(() => _isFlexible = val),
              ),
              
              const Divider(),
              const Text("Commission Logic", style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),
              const SizedBox(height: 8),

              Row(
                children: [
                  Expanded(
                    child: TextFormField(
                      controller: _commissionController,
                      style: const TextStyle(color: Colors.black),
                      decoration: _buildInputDecoration('Commission %', suffixText: '%'),
                      keyboardType: TextInputType.number,
                    ),
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: Container(
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(color: Colors.green.shade50, borderRadius: BorderRadius.circular(8)),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          const Text("Projected Profit", style: TextStyle(fontSize: 12, color: Colors.green)),
                          Text("â‚¹${_projectedProfit.toStringAsFixed(2)}", style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold, color: Colors.green)),
                        ],
                      ),
                    ),
                  ),
                ],
              ),
               const SizedBox(height: 16),

              // Summary
              Container(
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  border: Border.all(color: Colors.grey.shade300),
                  borderRadius: BorderRadius.circular(12),
                ),
                child: Column(
                  children: [
                    _buildSummaryRow("Total Collection", "â‚¹${_totalCollection.toStringAsFixed(2)}"),
                    const SizedBox(height: 8),
                    _buildSummaryRow("Platform Fee (-)", "â‚¹${_projectedProfit.toStringAsFixed(2)}", isNegative: true),
                    const Divider(height: 16),
                     _buildSummaryRow("Prize Pool (Available)", "â‚¹${_prizePoolController.text}", isBold: true),
                     const SizedBox(height: 8),
                     _buildSummaryRow("Total Payouts (-)", "â‚¹${_calculateTotalPayout().toStringAsFixed(0)}", isNegative: true),
                     const Divider(height: 16),
                     Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        const Text("Undistributed (Profit)", style: TextStyle(fontWeight: FontWeight.bold, fontSize: 14, color: Colors.green)),
                        Text(
                          "â‚¹${(double.parse(_prizePoolController.text.isEmpty ? "0" : _prizePoolController.text) - _calculateTotalPayout()).toStringAsFixed(0)}", 
                          style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 18, color: Colors.green)
                        ),
                      ],
                    ),
                  ],
                ),
              ),

              const SizedBox(height: 30),
              SizedBox(
                width: double.infinity,
                height: 50,
                child: ElevatedButton(
                  onPressed: _imageLoading ? null : _createContest,
                  style: ElevatedButton.styleFrom(backgroundColor: Colors.indigo, foregroundColor: Colors.white),
                  child: _imageLoading 
                    ? const CircularProgressIndicator(color: Colors.white) 
                    : const Text("CREATE CONTEST", style: TextStyle(fontWeight: FontWeight.bold)),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildSummaryRow(String label, String value, {bool isNegative = false, bool isBold = false}) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(label, style: TextStyle(fontSize: 16, color: Colors.black54, fontWeight: isBold ? FontWeight.bold : FontWeight.normal)),
        Text(value, style: TextStyle(
          fontSize: 16, 
          fontWeight: isBold ? FontWeight.bold : FontWeight.bold, // Value always bold? Or customizable.
          color: isNegative ? Colors.red : (isBold ? Colors.black : Colors.black)
        )),
      ],
    );
  }
}
